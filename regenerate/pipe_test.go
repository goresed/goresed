// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regenerate_test

import (
	"io"
	"os"
	"regexp"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/goresed/goresed/internal/testline"
	"github.com/goresed/goresed/regenerate"
)

func TestPipe(t *testing.T) {
	tests := []struct {
		line        string
		name        string
		input       string
		regenerates []regenerate.Option
		want        string
	}{
		{
			name: "Replace DBTX to DBTx.",
			line: testline.New(),
			input: `
// Code generated by sqlc. DO NOT EDIT.

package foo

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
`,
			regenerates: []regenerate.Option{
				regenerate.ReplaceString(
					"// Code generated by sqlc. DO NOT EDIT.",
					"// Code generated by sqlc. DO NOT EDIT.\n// Code regenerated by goresed. DO NOT EDIT.",
				),
				regenerate.ReplaceRegexp(
					regexp.MustCompile(`(?ms)^\nimport \(.*`),
					`
import (
	"context"

	"github.com/your/customsql"
)

func New(dbtxf func(context.Context) customsql.DBTx) *Queries {
	return &Queries{database: dbtxf}
}

type Queries struct {
	database func(context.Context) customsql.DBTx
}
`,
				),
			},
			want: `
// Code generated by sqlc. DO NOT EDIT.
// Code regenerated by goresed. DO NOT EDIT.

package foo

import (
	"context"

	"github.com/your/customsql"
)

func New(dbtxf func(context.Context) customsql.DBTx) *Queries {
	return &Queries{database: dbtxf}
}

type Queries struct {
	database func(context.Context) customsql.DBTx
}
`,
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name+"/"+tt.line, func(t *testing.T) {
			t.Parallel()

			r := strings.NewReader(tt.input)

			w, err := os.CreateTemp("", "")
			if err != nil {
				t.Fatalf("create temp os file: %s", err)
			}
			defer w.Close()

			err = regenerate.Pipe(r, w, tt.regenerates...)
			if err != nil {
				t.Fatalf("regenerate pipe: %s", err)
			}

			want := strings.TrimSpace(tt.want)

			s, err := io.ReadAll(w)
			if err != nil {
				t.Fatalf("io read all: %s", err)
			}

			get := strings.TrimSpace(string(s))

			if !cmp.Equal(want, get) && !testing.Verbose() {
				t.Errorf("\ntest: source diff/%s:\n%s", tt.line, cmp.Diff(want, get))

			} else if !cmp.Equal(want, get) {
				t.Errorf(
					"\ntest: source diff/%[1]s:\n%[2]s\nsource want/%[1]s:\n%[3]s\nsource get/%[1]s:\n%[4]s",
					tt.line, cmp.Diff(want, get), want, get,
				)
			}
		})
	}
}
