// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gsed_test

import (
	_ "embed"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/goresed/goresed/gsed"
	"github.com/goresed/goresed/internal/testline"
	"golang.org/x/tools/imports"
)

//go:embed goresed_reference_test.yaml
var yamlTestReference []byte

func TestWatch(t *testing.T) {
	tests := []struct {
		line          string
		name          string
		inputFiles    map[string]string
		inputYAML     string
		inputYAMLRefs []string
		wantFiles     map[string]string
	}{
		{
			name: "Replace DBTX to DBTx and db to database(ctx).",
			line: testline.New(),
			inputFiles: map[string]string{
				"foo/db.go": `
// Code generated by sqlc. DO NOT EDIT.

package foo

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
`,
				"foo/query.sql.go": `
// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package foo

import "context"

const countFoos = "SELECT count(*) FROM foos;"

func (q *Queries) CountFoos(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx)
	var count int64
	err := row.Scan(&count)
	return count, err
}
`,
			},
			inputYAML: `
regenerates:
  - file: "foo/db.go"
    replace: *regenerate_db

  - file: "foo/query.sql.go"
    replace: *regenerate_query

`,
			inputYAMLRefs: []string{
				string(yamlTestReference),
			},
			wantFiles: map[string]string{
				"foo/db.go": `
// Code generated by sqlc. DO NOT EDIT.
// Code regenerated by goresed. DO NOT EDIT.

package foo

import (
	"context"

	"github.com/your/customsql"
)

func New(dbtxf func(context.Context) customsql.DBTx) *Queries {
	return &Queries{database: dbtxf}
}

type Queries struct {
	database func(context.Context) customsql.DBTx
}
`,
				"foo/query.sql.go": `
// Code generated by sqlc. DO NOT EDIT.
// Code regenerated by goresed. DO NOT EDIT.
// source: query.sql

package foo

import "context"

const countFoos = "SELECT count(*) FROM foos;"

func (q *Queries) CountFoos(ctx context.Context) (int64, error) {
	row := q.database(ctx).QueryRow(ctx)
	var count int64
	err := row.Scan(&count)
	return count, err
}
`,
			},
		},
	}

	direcotry, err := ioutil.TempDir("", "test_goresed")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(direcotry)

	for _, tt := range tests {
		tt := tt
		t.Run(tt.name+"/"+tt.line, func(t *testing.T) {
			t.Parallel()

			dir := filepath.Join(direcotry, strings.Split(tt.line, ":")[1])

			for pth, file := range tt.inputFiles {
				err := os.MkdirAll(filepath.Dir(filepath.Join(dir, pth)), os.ModePerm)
				if err != nil {
					t.Fatalf("\nos make all dirs/%s\nerror: %s", tt.line, err)
				}

				f, err := os.OpenFile(filepath.Join(dir, pth), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
				if err != nil {
					t.Fatalf("\nos file create/%s\nerror: %s", tt.line, err)
				}

				_, err = f.Write([]byte(file))
				if err != nil {
					t.Fatalf("\nos file %s write/%s\nerror: %s", f.Name(), tt.line, err)
				}

				f.Close()
				if err != nil {
					t.Fatalf("\nos file %s close/%s\nerror: %s", f.Name(), tt.line, err)
				}
			}

			yml := strings.NewReader(tt.inputYAML)
			var refs []io.Reader

			for _, ref := range tt.inputYAMLRefs {
				refs = append(refs, strings.NewReader(ref))
			}

			var opts []gsed.Option

			opts = append(opts, gsed.WithReferences(refs...))
			opts = append(opts, gsed.WithDirectory(dir))

			gofmt := imports.Options{
				Fragment:  true,
				Comments:  true,
				TabIndent: true,
				TabWidth:  8,
			}

			opts = append(opts, gsed.WithGofmt(&gofmt))

			err = gsed.New(yml, opts...)
			if err != nil {
				t.Fatalf("\ngoresed new/%s\nerror: %s", tt.line, err)
			}

			var files []*os.File
			var paths []string

			err = filepath.Walk(dir, func(pth string, info os.FileInfo, _ error) error {
				if info.IsDir() {
					return nil
				}
				f, err := os.Open(pth)
				if err != nil {
					return err
				}
				files = append(files, f)
				paths = append(paths, strings.TrimPrefix(pth, dir))
				return nil
			})
			if err != nil {
				t.Fatal(err)
			}

			for _, f := range files {
				defer f.Close()
			}

			if len(files) != len(tt.wantFiles) {
				t.Errorf("\nfiles/%s\nwant files: %d\nget files/%d\n%+v", tt.line, len(files), len(tt.wantFiles), files)
			}

		filesLoop:
			for _, f := range files {
				get, err := ioutil.ReadAll(f)
				if err != nil {
					t.Fatal(err)
				}

				getPath := strings.TrimPrefix(f.Name(), dir+"/")

				for wantPath, wantFile := range tt.wantFiles {
					if wantPath != getPath {
						continue
					}

					want := strings.TrimSpace(wantFile)
					get := strings.TrimSpace(string(get))
					name := filepath.Base(getPath)

					if want != get && testing.Verbose() {
						t.Errorf(
							"\ntest: file %[2]s diff/%[1]s:\n%[3]s\nfile %[2]s want/%[1]s:\n%[4]s\nfile %[2]s get/%[1]s:\n%[5]s",
							tt.line, name, cmp.Diff(want, get), want, get,
						)
					} else if want != get {
						t.Errorf("\ntest: file %s diff/%s:\n%s", name, tt.line, cmp.Diff(want, get))
					}

					continue filesLoop
				}

				t.Errorf("unexpected file %q", getPath)
			}
		})
	}
}
